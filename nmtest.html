<!DOCTYPE html>
<html lang="en">

<head>
    <title>three.js vr - layers</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
</head>

<body>

    <div id="info">
        <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a>
        <br />
        <p> ‚≠ê Experimenting to see if we can use gpu compressed texture for our webxr layers. </p>
        <p> üòø This is hurting my noob brain</p>
        <p> ü•Ö Goal create two webxr quad layers.</p>
        <p> * One with an rgb data source </p>
        <p> * The other whose source will be a gpu compressed texture</p>
        <br />
    </div>

    <script src="./encoder/build/basis_loader.js"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "./three.js-master/three.js-master/build/three.module.js",
                "three/addons/": "./three.js-master/three.js-master/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
        import { HTMLMesh } from 'three/addons/interactive/HTMLMesh.js';
        import { InteractiveGroup } from 'three/addons/interactive/InteractiveGroup.js';
        import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
        import { XRHandModelFactory } from 'three/addons/webxr/XRHandModelFactory.js';
        import { KTX2Loader } from 'three/addons/loaders/KTX2Loader.js';
        import { CustomControls, CustomSkyCamera, setupScene, CustomRenderer, CustomControllers, WebXRCubeLayer, WebXREquirectangularLayer } from './main.js';


        let scene, camera, renderer, controls, controllers, group, ktx2Loader, gl, glBinding, xrSpace, xrSession;

        //Our webxr layers
        let equirectLayer, cubeLayer = null;
        let eqrtRadius = 40;

        //resize event
        window.addEventListener('resize', onWindowResize, false);

        //create scene, add lights and some geometry
        scene = new THREE.Scene();
        setupScene(scene)

        //create camera
        camera = new CustomSkyCamera().camera;

        //create renderer, add it to the dom and set animation loop
        renderer = new CustomRenderer().renderer;
        console.log('renderer', renderer)
       
        document.body.appendChild(renderer.domElement);
        renderer.setAnimationLoop(animate);

        //add vr button
        document.body.appendChild(VRButton.createButton(renderer));

        //add pc controls ('awsd' to move, mouse to look around)
        controls = new CustomControls(camera, renderer).controls;

        //create vr hand controls with models
        controllers = new CustomControllers(scene, renderer).controllers;

        //create interactive group
        group = new InteractiveGroup();
        group.listenToXRControllerEvents(controllers[0]);
        group.listenToXRControllerEvents(controllers[1]);
        scene.add(group);

        //webgl context
        gl = renderer.getContext();
        console.log('gl', gl)
        //create ktx2 loader ?maybe should be a function?
        ktx2Loader = new KTX2Loader();
        ktx2Loader.setTranscoderPath('https://cdn.jsdelivr.net/npm/three@0.154.0/examples/jsm/libs/basis/');
        ktx2Loader.detectSupport(renderer);

        //our sources
        // let sources = ['./textures/compressedCubeMaps/cubemapLeft.ktx2', './textures/compressedCubeMaps/cubemapRight.ktx2', './textures/compressedCubeMaps/cubemap_uastc.ktx2', './textures/compressed360Stereo/example.ktx2'] //'./textures/compressed360Stereo/example.ktx2'  

        // let sources = ['./textures/compressed360/2022_03_30_Gemini_North_360_Outside_08-CC_uastc.ktx2',
        //     './textures/compressed360/bf4.ktx2',
        //     './textures/compressed360/Italy_Mountains.ktx2',
        //     './textures/compressed360/SnowySnow360.ktx2',
        //     './textures/compressed360/Mountain.ktx2'

        // ]

        let sources = ['./textures/compressed360Stereo/bf4.ktx2']
        
        //get compressed texture extensions
        const ASTC_EXT = gl.getExtension("WEBGL_compressed_texture_astc")
        const ETC_EXT = gl.getExtension("WEBGL_compressed_texture_etc")

        if (ASTC_EXT) console.log("ASTC_EXT", ASTC_EXT)
        if (ETC_EXT) console.log("ETC_EXT", ETC_EXT)

        //Our three js compressed textures
        let compressed360Textures = []
        let compressedCubeTextures = []
        let activeWebXRLayer = null;


        //supported compressed formats
        const supportedCompressedFormats = new Map([
            [37496, "ETC_EXT.COMPRESSED_RGBA8_ETC2_EAC"],
            [37492, "ETC_EXT.COMPRESSED_RGB8_ETC2"],
            [37808, "ASTC_EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR"],
            [1023, "srgb"]

        ]);


        //better design is creating key value pairs mapping the texture src image name to the texture object
        //storing all the textures in a single object
        for (let i = 0; i < sources.length; i++) {
            getTexturedData(sources[i])
        }
        // getTexturedData();

        //create a compressed texture
        //this will be completely refactored, just testing handling different compressed formats
        function getTexturedData(url = sources[0]) {

            ktx2Loader.load(url,
                (texture) => {

                    if (texture.isCompressedCubeTexture) {
                        console.log("creating cube texture")
                        compressedCubeTextures.push(texture)

                    } else if (texture.isCompressedTexture) {

                        console.log("creating equirectangular texture")
                        compressed360Textures.push(texture)

                    }

                }, null, null);
        }

        function createEquireLayer(texture, stereo = false) {


            let format = eval(supportedCompressedFormats.get(texture.format))
            let sphere_layer = new WebXREquirectangularLayer(null, texture, stereo, xrSpace, glBinding, format, eqrtRadius);
            sphere_layer.createLayer()
            activeWebXRLayer = sphere_layer

            xrSession.updateRenderState({
                layers: [
                    activeWebXRLayer.equirectangularLayer,
                    xrSession.renderState.layers[xrSession.renderState.layers.length - 1]
                ]
            });


        }

        function createEqrtLayerByIndex(index, stereo = false) {

            if (index >= compressed360Textures.length) {
                console.log("index out of range");
                return null;
            }
            console.log("creating equirectangular layer stereo = ", stereo)

            createEquireLayer(compressed360Textures[index], stereo)

        }

       


        function createCubeLayer(texture, texture_right = null, stereo = false) {

            let format = eval(supportedCompressedFormats.get(texture.format))
            let cubeLayer

            if (!stereo) {
                cubeLayer = new WebXRCubeLayer(null, texture, null, false, xrSpace, glBinding, format);
            } else {
                cubeLayer = new WebXRCubeLayer(null, texture, texture_right, true, xrSpace, glBinding, format);
            }


            cubeLayer.createLayer()
            activeWebXRLayer = cubeLayer

            xrSession.updateRenderState({
                layers: [
                    activeWebXRLayer.cubeLayer,
                    xrSession.renderState.layers[xrSession.renderState.layers.length - 1]
                ]
            });
        }





        function createCubeLayerByIndex(index) {

            if (index >= compressedCubeTextures.length) {
                console.log("index out of range");
                return null;
            }
            
            createCubeLayer(compressedCubeTextures[index], null, false)

        }

        function createCubeLayerByIndexStereo(index_left, index_right) {
            if (index_left >= compressedCubeTextures.length || index_right >= compressedCubeTextures.length) {
                console.log("index out of range");
                console.log(compressedCubeTextures.length)
                return null;
            }

            if (compressedCubeTextures[index_left].format !== compressedCubeTextures[index_right].format) {
                console.log("formats do not match")
                return null;
            }


            createCubeLayer(compressedCubeTextures[index_left], compressedCubeTextures[index_right], true)

        }

        window.createCubeLayerByIndex = createCubeLayerByIndex
        window.createCubeLayerByIndexStereo = createCubeLayerByIndexStereo
        window.createEqrtLayerByIndex = createEqrtLayerByIndex

        //animation loop
        function animate(t, frame) {

            const xr = renderer.xr;
            const session = xr.getSession();
            xrSession = session;
            if (session && session.renderState.layers !== undefined && session.hasMediaLayer === undefined
            ) {

                console.log("creating media layer")
                session.hasMediaLayer = true;
                session.requestReferenceSpace('local-floor').then((refSpace) => {

                    glBinding = xr.getBinding();
                    xrSpace = refSpace;
                    // createEquireLayer(compressed360Textures[0], null, false)    


                });

            }

            if (session && activeWebXRLayer && activeWebXRLayer.type === "WebXREquirectangularLayer" && activeWebXRLayer.equirectangularLayer.needsRedraw) {

                let format = eval(activeWebXRLayer.format);
                let width = activeWebXRLayer.Equirectangular_Texture.mipmaps[0].width;
                let height = activeWebXRLayer.Equirectangular_Texture.mipmaps[0].height;

                let glayer = glBinding.getSubImage(activeWebXRLayer.equirectangularLayer, frame);
                    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
                    gl.bindTexture(gl.TEXTURE_2D, glayer.colorTexture);
                    gl.compressedTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, width, height, format, activeWebXRLayer.Equirectangular_Texture.mipmaps[0].data);
                    gl.bindTexture(gl.TEXTURE_2D, null);
                
                    if (!activeWebXRLayer.stereo) {
                  

                } 
               



            } else if (session && activeWebXRLayer && activeWebXRLayer.type === "WebXRCubeLayer" && activeWebXRLayer.cubeLayer.needsRedraw) {

                let format = eval(activeWebXRLayer.format);
                let width = activeWebXRLayer.Cube_Texture.source.data[0].width;

                if (!activeWebXRLayer.stereo) {
                    let glayer = glBinding.getSubImage(activeWebXRLayer.cubeLayer, frame);
                    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
                    gl.bindTexture(gl.TEXTURE_CUBE_MAP, glayer.colorTexture);


                    gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X, 0, 0, 0, width, width, format, activeWebXRLayer.Cube_Texture.source.data[0].mipmaps[0].data); //es
                    gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, 0, 0, width, width, format, activeWebXRLayer.Cube_Texture.source.data[1].mipmaps[0].data); //es
                    gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, 0, 0, width, width, format, activeWebXRLayer.Cube_Texture.source.data[2].mipmaps[0].data); //es
                    gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, 0, 0, width, width, format, activeWebXRLayer.Cube_Texture.source.data[3].mipmaps[0].data); //es
                    gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, 0, 0, width, width, format, activeWebXRLayer.Cube_Texture.source.data[4].mipmaps[0].data); //es
                    gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, 0, 0, width, width, format, activeWebXRLayer.Cube_Texture.source.data[5].mipmaps[0].data); //es

                    gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
                } else {

                    let glayer = glBinding.getSubImage(activeWebXRLayer.cubeLayer, frame, "left");
                    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
                    gl.bindTexture(gl.TEXTURE_CUBE_MAP, glayer.colorTexture);


                    gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X, 0, 0, 0, width, width, format, activeWebXRLayer.Cube_Texture.source.data[0].mipmaps[0].data); //es
                    gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, 0, 0, width, width, format, activeWebXRLayer.Cube_Texture.source.data[1].mipmaps[0].data); //es
                    gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, 0, 0, width, width, format, activeWebXRLayer.Cube_Texture.source.data[2].mipmaps[0].data); //es
                    gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, 0, 0, width, width, format, activeWebXRLayer.Cube_Texture.source.data[3].mipmaps[0].data); //es
                    gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, 0, 0, width, width, format, activeWebXRLayer.Cube_Texture.source.data[4].mipmaps[0].data); //es
                    gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, 0, 0, width, width, format, activeWebXRLayer.Cube_Texture.source.data[5].mipmaps[0].data); //es

                    gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);

                    glayer = glBinding.getSubImage(activeWebXRLayer.cubeLayer, frame, "right");
                    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
                    gl.bindTexture(gl.TEXTURE_CUBE_MAP, glayer.colorTexture);


                    gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X, 0, 0, 0, width, width, format, activeWebXRLayer.Cube_Texture_Right.source.data[0].mipmaps[0].data); //es
                    gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, 0, 0, width, width, format, activeWebXRLayer.Cube_Texture_Right.source.data[1].mipmaps[0].data); //es
                    gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, 0, 0, width, width, format, activeWebXRLayer.Cube_Texture_Right.source.data[2].mipmaps[0].data); //es
                    gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, 0, 0, width, width, format, activeWebXRLayer.Cube_Texture_Right.source.data[3].mipmaps[0].data); //es
                    gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, 0, 0, width, width, format, activeWebXRLayer.Cube_Texture_Right.source.data[4].mipmaps[0].data); //es
                    gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, 0, 0, width, width, format, activeWebXRLayer.Cube_Texture_Right.source.data[5].mipmaps[0].data); //es


                    gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);



                }

            }

            renderer.render(scene, camera);
            controls.update();

        }







        //utils

        function onWindowResize() {
            console.log('resize')
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);

        }

    </script>

</body>

</html>