<!DOCTYPE html>
<html lang="en">

<head>
    <title>three.js vr - layers</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
</head>

<body>

    <div id="info">
        <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a>
        <br />
        <p> ‚≠ê Experimenting to see if we can use gpu compressed texture for our webxr layers. </p>
        <p> üòø This is hurting my noob brain</p>
        <p> ü•Ö Goal create two webxr quad layers.</p>
        <p> * One with an rgb data source </p>
        <p> * The other whose source will be a gpu compressed texture</p>
        <br />
    </div>

    <script src="./encoder/build/basis_loader.js"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "./three.js-master/three.js-master/build/three.module.js",
                "three/addons/": "./three.js-master/three.js-master/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
        import { HTMLMesh } from 'three/addons/interactive/HTMLMesh.js';
        import { InteractiveGroup } from 'three/addons/interactive/InteractiveGroup.js';
        import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
        import { XRHandModelFactory } from 'three/addons/webxr/XRHandModelFactory.js';
        import { KTX2Loader } from 'three/addons/loaders/KTX2Loader.js';
        import { customControls, customSkyCamera, setupScene, customRenderer, customControllers, WebXRCubeLayer, WebXREquirectangularLayer } from './main.js';


        let scene, camera, renderer, controls, controllers, group, ktx2Loader, gl, glBinding, xrSpace, xrSession;

        //Our webxr layers
        let equirectLayer, cubeLayer = null;
        let eqrtRadius = 40;
        let stereo = false
        //resize event
        window.addEventListener('resize', onWindowResize, false);

        //create scene, add lights and random geometry
        scene = new THREE.Scene();
        setupScene(scene)

        //create camera
        camera = new customSkyCamera().camera;

        //create renderer, add it to the dom and set animation loop
        renderer = new customRenderer().renderer;
        document.body.appendChild(renderer.domElement);
        renderer.setAnimationLoop(animate);

        //add vr button
        document.body.appendChild(VRButton.createButton(renderer));

        //add pc controls ('awsd' to move, mouse to look around)
        controls = new customControls(camera, renderer).controls;

        //create vr hand controls with models
        controllers = new customControllers(scene, renderer).controllers;

        //create interactive group
        group = new InteractiveGroup();
        group.listenToXRControllerEvents(controllers[0]);
        group.listenToXRControllerEvents(controllers[1]);
        scene.add(group);

        //webgl context
        gl = renderer.getContext();
        console.log(gl)

        //create ktx2 loader ?maybe should be a function?
        ktx2Loader = new KTX2Loader();
        ktx2Loader.setTranscoderPath('https://cdn.jsdelivr.net/npm/three@0.154.0/examples/jsm/libs/basis/');
        ktx2Loader.detectSupport(renderer);

        //our sources
        // let sources = ['./textures/compressedCubeMaps/cubemapLeft.ktx2', './textures/compressedCubeMaps/cubemapRight.ktx2', './textures/compressedCubeMaps/cubemap_uastc.ktx2', './textures/compressed360Stereo/example.ktx2'] //'./textures/compressed360Stereo/example.ktx2'  

        // let sources = ['./textures/compressed360/2022_03_30_Gemini_North_360_Outside_08-CC_uastc.ktx2',
        //     './textures/compressed360/bf4.ktx2',
        //     './textures/compressed360/Italy_Mountains.ktx2',
        //     './textures/compressed360/SnowySnow360.ktx2',
        //     './textures/compressed360/Mountain.ktx2'

        // ]

        let sources = [
            './textures/compressed360Stereo/bf4.ktx2'
          
        ]
        //get compressed texture extensions
        let astc_ext = gl.getExtension("WEBGL_compressed_texture_astc")
        let etc_ext = gl.getExtension("WEBGL_compressed_texture_etc")

        if (astc_ext) console.log("astc_ext", astc_ext)
        if (etc_ext) console.log("etc_ext", etc_ext)

        //Our three js compressed textures
        let compressed360Textures = []
        let active_360_Texture = null
        let active_Cube_Texture = null
        let active_Cube_Texture_Right = null

        let active_WebXR_Layer = null;

        // let compressed360StereoTextures = []
        let compressedCubeTextures = []

        window.compressed360Textures = compressed360Textures
        // let compressedCubeStereoTextures = []



        //supported compressed formats
        const supportedCompressedFormats = new Map([
            [37496, "etc_ext.COMPRESSED_RGBA8_ETC2_EAC"],
            [37492, "etc_ext.COMPRESSED_RGB8_ETC2"],
            [37808, "astc_ext.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR"],
            [1023, "srgb"]

        ]);


        //better design is creating key value pairs mapping the texture src image name to the texture object
        //storing all the textures in a single object
        for (let i = 0; i < sources.length; i++) {
            getTexturedData(sources[i])
        }
        // getTexturedData();

        //create a compressed texture
        //this will be completely refactored, just testing handling different compressed formats
        function getTexturedData(url = sources[0]) {

            ktx2Loader.load(url,
                (texture) => {

                    if (texture.isCompressedCubeTexture) {
                        console.log("creating cube texture")
                        compressedCubeTextures.push(texture)

                    } else if (texture.isCompressedTexture) {

                        console.log("creating equirectangular texture")
                        compressed360Textures.push(texture)
                        //  active_360_Texture = compressed360Textures[0]

                    }

                }, null, null);
        }

        function createEquireLayer(texture_left, texture_right, stereo = false) {

            console.log(texture_left)

            let format = eval(supportedCompressedFormats.get(texture_left.format))

            let sphere_layer

            if (!stereo) {
                sphere_layer = new WebXREquirectangularLayer(null, texture_left, null, false, xrSpace, glBinding, format, eqrtRadius);

            } else {
                sphere_layer = new WebXREquirectangularLayer(null, texture_left, texture_right, true, xrSpace, glBinding, format, eqrtRadius);

            }
            sphere_layer.createLayer()
            active_WebXR_Layer = sphere_layer

            xrSession.updateRenderState({
                layers: [
                    active_WebXR_Layer.equirectangularLayer,
                    xrSession.renderState.layers[xrSession.renderState.layers.length - 1]
                ]
            });


        }

        function createEqrtLayerByIndex(index) {

            if (index >= compressed360Textures.length) {
                console.log("index out of range");
                return null;
            }
            createEquireLayer(compressed360Textures[index], null, false)

        }

        function createEqrtLayerByIndexStereo(index_left, index_right) {

            if (index_left >= compressed360Textures.length || index_right >= compressed360Textures.length) {
                console.log("index out of range");
                console.log(compressed360Textures.length)
                return null;
            }

            if (compressed360Textures[index_left].format !== compressed360Textures[index_right].format) {
                console.log("formats do not match")
                return null;
            }

            if(compressed360Textures[index_left].width !== compressed360Textures[index_right].width){
                console.log("unequal width")
                return null;

            }


            // active_Cube_Texture = compressedCubeTextures[index_left]
            // active_Cube_Texture_Right = compressedCubeTextures[index_right]

            createEquireLayer(compressed360Textures[index_left], compressed360Textures[index_right], true)  
        }


        function createCubeLayer(texture = active_Cube_Texture, texture_right = null, stereo = false) {

            let format = eval(supportedCompressedFormats.get(texture.format))
            let cube_layer

            if (!stereo) {
                cube_layer = new WebXRCubeLayer(null, texture, null, false, xrSpace, glBinding, format);
            } else {
                cube_layer = new WebXRCubeLayer(null, texture, texture_right, true, xrSpace, glBinding, format);
            }


            cube_layer.createLayer()
            active_WebXR_Layer = cube_layer

            xrSession.updateRenderState({
                layers: [
                    active_WebXR_Layer.cubeLayer,
                    xrSession.renderState.layers[xrSession.renderState.layers.length - 1]
                ]
            });
        }





        function createCubeLayerByIndex(index) {

            if (index >= compressedCubeTextures.length) {
                console.log("index out of range");
                return null;
            }
            active_Cube_Texture = compressedCubeTextures[index]
            createCubeLayer()

        }

        function createCubeLayerByIndexStereo(index_left, index_right) {
            if (index_left >= compressedCubeTextures.length || index_right >= compressedCubeTextures.length) {
                console.log("index out of range");
                console.log(compressedCubeTextures.length)
                return null;
            }

            if (compressedCubeTextures[index_left].format !== compressedCubeTextures[index_right].format) {
                console.log("formats do not match")
                return null;
            }

            active_Cube_Texture = compressedCubeTextures[index_left]
            active_Cube_Texture_Right = compressedCubeTextures[index_right]


            createCubeLayer(active_Cube_Texture, active_Cube_Texture_Right, true)

        }

        window.createCubeLayerByIndex = createCubeLayerByIndex
        window.createCubeLayerByIndexStereo = createCubeLayerByIndexStereo
        window.createEqrtLayerByIndex = createEqrtLayerByIndex
        window.createEqrtLayerByIndexStereo = createEqrtLayerByIndexStereo
        //animation loop
        function animate(t, frame) {

            const xr = renderer.xr;
            const session = xr.getSession();
            xrSession = session;
            if (session && session.renderState.layers !== undefined && session.hasMediaLayer === undefined
            ) {

                console.log("creating media layer")
                session.hasMediaLayer = true;
                session.requestReferenceSpace('local-floor').then((refSpace) => {

                    glBinding = xr.getBinding();
                    xrSpace = refSpace;
                    // createEquireLayer(compressed360Textures[0], null, false)    


                });

            }

            if (session && active_WebXR_Layer && active_WebXR_Layer.type === "WebXREquirectangularLayer" && active_WebXR_Layer.equirectangularLayer.needsRedraw) {

                let format = eval(active_WebXR_Layer.format);
                let width = active_WebXR_Layer.Equirectangular_Texture.mipmaps[0].width;
                let height = active_WebXR_Layer.Equirectangular_Texture.mipmaps[0].height;

                let glayer = glBinding.getSubImage(active_WebXR_Layer.equirectangularLayer, frame);
                    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
                    gl.bindTexture(gl.TEXTURE_2D, glayer.colorTexture);
                    gl.compressedTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, width, height, format, active_WebXR_Layer.Equirectangular_Texture.mipmaps[0].data);
                    gl.bindTexture(gl.TEXTURE_2D, null);
                
                    if (!active_WebXR_Layer.stereo) {
                  

                } 
                // else {
                //     let glayer = glBinding.getSubImage(active_WebXR_Layer.equirectangularLayer, frame, "left");
                //     gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
                //     gl.bindTexture(gl.TEXTURE_2D, glayer.colorTexture);
                //     gl.compressedTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, width, height, format, active_WebXR_Layer.Equirectangular_Texture.mipmaps[0].data);
                //     gl.bindTexture(gl.TEXTURE_2D, null);

                //     glayer = glBinding.getSubImage(active_WebXR_Layer.equirectangularLayer, frame, "right");
                //     gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
                //     gl.bindTexture(gl.TEXTURE_2D, glayer.colorTexture);
                //     gl.compressedTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, width, height, format, active_WebXR_Layer.Equirectangular_Texture.mipmaps[0].data);
                //     gl.bindTexture(gl.TEXTURE_2D, null);

                // }



            } else if (session && active_WebXR_Layer && active_WebXR_Layer.type === "WebXRCubeLayer" && active_WebXR_Layer.cubeLayer.needsRedraw) {

                let format = eval(active_WebXR_Layer.format);
                let width = active_WebXR_Layer.Cube_Texture.source.data[0].width;

                if (!active_WebXR_Layer.stereo) {
                    let glayer = glBinding.getSubImage(active_WebXR_Layer.cubeLayer, frame);
                    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
                    gl.bindTexture(gl.TEXTURE_CUBE_MAP, glayer.colorTexture);


                    gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X, 0, 0, 0, width, width, format, active_WebXR_Layer.Cube_Texture.source.data[0].mipmaps[0].data); //es
                    gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, 0, 0, width, width, format, active_WebXR_Layer.Cube_Texture.source.data[1].mipmaps[0].data); //es
                    gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, 0, 0, width, width, format, active_WebXR_Layer.Cube_Texture.source.data[2].mipmaps[0].data); //es
                    gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, 0, 0, width, width, format, active_WebXR_Layer.Cube_Texture.source.data[3].mipmaps[0].data); //es
                    gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, 0, 0, width, width, format, active_WebXR_Layer.Cube_Texture.source.data[4].mipmaps[0].data); //es
                    gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, 0, 0, width, width, format, active_WebXR_Layer.Cube_Texture.source.data[5].mipmaps[0].data); //es

                    gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
                } else {

                    let glayer = glBinding.getSubImage(active_WebXR_Layer.cubeLayer, frame, "left");
                    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
                    gl.bindTexture(gl.TEXTURE_CUBE_MAP, glayer.colorTexture);


                    gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X, 0, 0, 0, width, width, format, active_WebXR_Layer.Cube_Texture.source.data[0].mipmaps[0].data); //es
                    gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, 0, 0, width, width, format, active_WebXR_Layer.Cube_Texture.source.data[1].mipmaps[0].data); //es
                    gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, 0, 0, width, width, format, active_WebXR_Layer.Cube_Texture.source.data[2].mipmaps[0].data); //es
                    gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, 0, 0, width, width, format, active_WebXR_Layer.Cube_Texture.source.data[3].mipmaps[0].data); //es
                    gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, 0, 0, width, width, format, active_WebXR_Layer.Cube_Texture.source.data[4].mipmaps[0].data); //es
                    gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, 0, 0, width, width, format, active_WebXR_Layer.Cube_Texture.source.data[5].mipmaps[0].data); //es

                    gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);

                    glayer = glBinding.getSubImage(active_WebXR_Layer.cubeLayer, frame, "right");
                    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
                    gl.bindTexture(gl.TEXTURE_CUBE_MAP, glayer.colorTexture);


                    gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X, 0, 0, 0, width, width, format, active_WebXR_Layer.Cube_Texture_Right.source.data[0].mipmaps[0].data); //es
                    gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, 0, 0, width, width, format, active_WebXR_Layer.Cube_Texture_Right.source.data[1].mipmaps[0].data); //es
                    gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, 0, 0, width, width, format, active_WebXR_Layer.Cube_Texture_Right.source.data[2].mipmaps[0].data); //es
                    gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, 0, 0, width, width, format, active_WebXR_Layer.Cube_Texture_Right.source.data[3].mipmaps[0].data); //es
                    gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, 0, 0, width, width, format, active_WebXR_Layer.Cube_Texture_Right.source.data[4].mipmaps[0].data); //es
                    gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, 0, 0, width, width, format, active_WebXR_Layer.Cube_Texture_Right.source.data[5].mipmaps[0].data); //es


                    gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);



                }

            }

            renderer.render(scene, camera);
            controls.update();

        }







        //utils

        function onWindowResize() {
            console.log('resize')
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);

        }

    </script>

</body>

</html>